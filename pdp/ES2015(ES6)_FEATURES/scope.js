// Область видимости (scope) устанавливает, где и когда
//  определяются переменные,константы и аргументы.
//  Мы уже имеем некоторое представление об области видимости:
// нам известно, что аргументы функции существуют
// только в теле функции.

console.log("перед блоком");
{
  console.log("внутри блока");
  const x = 3;
  console.log(x);
}
// console.log(`За пределами блока ${x}`);

// Маскировку переменных иногда называют затенением (shadowing)
// ( т.е. переменная из внешней области видимости
// попадает в тень переменнойс тем же именем во внутренней области)
{
  let x = { color: "blue" };
  let y = x;
  let z = 3;
  {
    let x = 5;
    console.log(x);
    console.log(y.color);

    y.color = "red";
    console.log(z);
  }
  console.log(x);
  console.log(x.color);
  console.log(y.color);
  console.log(z);
}

// Довольно часто фун кцию преднамеренно определяют
// в некоторой области видимости,чтобы гарантированно
// получить доступ к переменным из этой области.
// В результате получается замкнутое выражение
// (closure) (вы можете считать его областью
// видимости, замкнутой вокруг функции).

let globalFunc;
{
  let blockVar = "a";
  globalFunc = function () {
    console.log(blockVar);
  };
}
globalFunc();

// Обычно нечто вне области видимости строго
// недоступно. Функции являются исключением,
// они предоставляют нам окна в области видимости,
//  которые в противном случае были бы недоступны.
let f;
{
  let o = { note: "Безопасно" };
  f = function () {
    console.log(o);
    return o;
  };
}
let oRef = f();
oRef.note = "Все же не безопасно";
f();

//-----Немедленно вызываемые функциональные выражения------
// Переменная secret защищена в области видимости
// IIFE, к ней нельзя обратиться извне.
const message = (function () {
  const secret = "Здесь указан пароль";
  return `Пароль имеет длину ${secret.length} символов`;
})();
console.log(message);

{
  // Поскольку переменная count надежно защищена в IIFE,
  //  нет никакого способа изменить ее из вне: у функции
  //   f всегда будет точный подсчет количества раз,
  //   когда онабыла вызвана.
  const f = (function () {
    let count = 0;
    return function () {
      return `Меня вызвали ${++count} раз`;
    };
  })();
  console.log(f());
  console.log(f());
  f();
  console.log(f());
}

// Обратите внимание, что функциональные выражения,
// которые присваиваются переменным, не поднимаются.
// Они просто подчиняются правилам областей видимости
// для переменных, как показано ниже.
{
  fu();
  function fu() {
    console.log("f");
  }
}
// {
//   fun();
//   let fun = function () {
//     console.log("f");
//   };
// }
